/* QueryExpressionParser.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. QueryExpressionParser.java */
package minibase.query.optimizer.parser;

import minibase.catalog.DataType;
import minibase.catalog.SortOrder;
import minibase.query.optimizer.operators.OperatorType;
import minibase.query.optimizer.operators.element.Comparison.ComparisonOperator;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Parser for Cascades/Columbia-style query expressions.
 *
 * @author Michael Grossniklaus &lt;michael.grossniklaus@uni-konstanz.de&gt;
 */
@SuppressWarnings({"unused"})
public class QueryExpressionParser/*@bgen(jjtree)*/ implements QueryExpressionParserTreeConstants, QueryExpressionParserConstants {/*@bgen(jjtree)*/
    protected JJTQueryExpressionParserState jjtree = new JJTQueryExpressionParserState();

    /**
     * Parses a query expression.
     *
     * @param in input stream to parse
     * @return parsed query expression
     * @throws ParseException in the input contains a syntax error
     */
    public static QueryExpression parse(final InputStream in) throws ParseException {
        final QueryExpressionParser parser = new QueryExpressionParser(in);
        return parser.Expression();
    }

    final public QueryExpression Expression() throws ParseException {/*@bgen(jjtree) Expression */
        QueryExpression jjtn000 = new QueryExpression(JJTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case K_GET:
                case K_ATTR:
                case K_INT:
                case K_FLOAT:
                case K_STR:
                case K_DATE: {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case K_GET: {
                            GetTable();
                            break;
                        }
                        case K_ATTR: {
                            GetColumn();
                            break;
                        }
                        case K_INT:
                        case K_FLOAT:
                        case K_STR:
                        case K_DATE: {
                            Constant();
                            break;
                        }
                        default:
                            jj_la1[0] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                }
                case O_LPAREN: {
                    jj_consume_token(O_LPAREN);
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case K_SELECT: {
                            Selection();
                            break;
                        }
                        case K_PROJECT: {
                            Projection();
                            break;
                        }
                        case K_EQJOIN: {
                            EquiJoin();
                            break;
                        }
                        case K_DISTINCT: {
                            Distinct();
                            break;
                        }
                        case K_ORDER_BY: {
                            OrderBy();
                            break;
                        }
                        case K_AGG_LIST: {
                            GroupByAggregate();
                            break;
                        }
                        case K_OP_AND:
                        case K_OP_OR:
                        case K_OP_NOT:
                        case K_OP_EQ:
                        case K_OP_LT:
                        case K_OP_LEQ:
                        case K_OP_GT:
                        case K_OP_GEQ:
                        case K_OP_NEQ:
                        case K_OP_LIKE:
                        case K_OP_IN: {
                            Comparison();
                            break;
                        }
                        default:
                            jj_la1[1] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    label_1:
                    while (true) {
                        jj_consume_token(O_COMMA);
                        Expression();
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case O_COMMA: {
                                ;
                                break;
                            }
                            default:
                                jj_la1[2] = jj_gen;
                                break label_1;
                        }
                    }
                    jj_consume_token(O_RPAREN);
                    break;
                }
                default:
                    jj_la1[3] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if ("" != null) return jjtn000;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void GetTable() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        String name;
        Optional<String> alias = Optional.empty();
        try {
            jj_consume_token(K_GET);
            jjtn000.setType(OperatorType.GETTABLE);
            jj_consume_token(O_LPAREN);
            jj_consume_token(S_IDENTIFIER);
            name = token.image;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case O_COMMA: {
                    jj_consume_token(O_COMMA);
                    jj_consume_token(S_IDENTIFIER);
                    alias = Optional.of(token.image);
                    break;
                }
                default:
                    jj_la1[4] = jj_gen;
                    ;
            }
            jjtn000.setArguments(name, alias);
            jj_consume_token(O_RPAREN);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void GetColumn() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        QueryColumn column;
        try {
            jj_consume_token(K_ATTR);
            jjtn000.setType(OperatorType.GETCOLUMN);
            jj_consume_token(O_LPAREN);
            column = Column();
            jjtn000.setArguments(column);
            jj_consume_token(O_RPAREN);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void Constant() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case K_INT: {
                IntConstant();
                break;
            }
            case K_FLOAT: {
                FloatConstant();
                break;
            }
            case K_STR: {
                StrConstant();
                break;
            }
            case K_DATE: {
                DateConstant();
                break;
            }
            default:
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    final public void IntConstant() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_INT);
            jjtn000.setType(OperatorType.CONSTANT);
            jj_consume_token(O_LPAREN);
            jj_consume_token(S_INTEGER);
            jjtn000.setArguments(token.image, DataType.INT);
            jj_consume_token(O_RPAREN);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void FloatConstant() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_FLOAT);
            jjtn000.setType(OperatorType.CONSTANT);
            jj_consume_token(O_LPAREN);
            jj_consume_token(S_FLOAT);
            jjtn000.setArguments(token.image, DataType.FLOAT);
            jj_consume_token(O_RPAREN);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void StrConstant() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_STR);
            jjtn000.setType(OperatorType.CONSTANT);
            jj_consume_token(O_LPAREN);
            jj_consume_token(S_STRING);
            jjtn000.setArguments(token.image.substring(1, token.image.length() - 1), DataType.CHAR);
            jj_consume_token(O_RPAREN);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void DateConstant() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_DATE);
            jjtn000.setType(OperatorType.CONSTANT);
            jj_consume_token(O_LPAREN);
            jj_consume_token(S_DATE);
            jjtn000.setArguments(token.image, DataType.DATE);
            jj_consume_token(O_RPAREN);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void Selection() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_SELECT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setType(OperatorType.SELECT);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void Projection() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<QueryColumn> columns;
        try {
            jj_consume_token(K_PROJECT);
            jjtn000.setType(OperatorType.PROJECT);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case O_LPAREN: {
                    jj_consume_token(O_LPAREN);
                    columns = ColumnList();
                    jjtn000.setArguments(columns);
                    jj_consume_token(O_RPAREN);
                    break;
                }
                default:
                    jj_la1[6] = jj_gen;
                    ;
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void EquiJoin() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<QueryColumn> leftColumns;
        List<QueryColumn> rightColumns;
        try {
            jj_consume_token(K_EQJOIN);
            jjtn000.setType(OperatorType.EQJOIN);
            jj_consume_token(O_LPAREN);
            leftColumns = ColumnList();
            jj_consume_token(O_COMMA);
            rightColumns = ColumnList();
            jj_consume_token(O_RPAREN);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setArguments(leftColumns, rightColumns);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void Distinct() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(K_DISTINCT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setType(OperatorType.DISTINCT);
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void OrderBy() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<QuerySortColumn> sortColumns;
        try {
            jj_consume_token(K_ORDER_BY);
            jjtn000.setType(OperatorType.SORT);
            jj_consume_token(O_LPAREN);
            sortColumns = SortColumnList();
            jjtn000.setArguments(sortColumns);
            jj_consume_token(O_RPAREN);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public List<QuerySortColumn> SortColumnList() throws ParseException {
        QuerySortColumn column;
        List<QuerySortColumn> columns = new ArrayList<QuerySortColumn>();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case O_DOT:
            case S_IDENTIFIER: {
                column = SortColumn();
                columns.add(column);
                break;
            }
            case O_LT: {
                jj_consume_token(O_LT);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case O_DOT:
                    case S_IDENTIFIER: {
                        column = SortColumn();
                        columns.add(column);
                        label_2:
                        while (true) {
                            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                case O_COMMA: {
                                    ;
                                    break;
                                }
                                default:
                                    jj_la1[7] = jj_gen;
                                    break label_2;
                            }
                            jj_consume_token(O_COMMA);
                            column = SortColumn();
                            columns.add(column);
                        }
                        break;
                    }
                    default:
                        jj_la1[8] = jj_gen;
                        ;
                }
                jj_consume_token(O_GT);
                break;
            }
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return columns;
        }
        throw new Error("Missing return statement in function");
    }

    final public QuerySortColumn SortColumn() throws ParseException {
        QueryColumn column;
        SortOrder order = SortOrder.ASCENDING;
        column = Column();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case K_ASC:
            case K_DESC: {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case K_ASC: {
                        jj_consume_token(K_ASC);
                        break;
                    }
                    case K_DESC: {
                        jj_consume_token(K_DESC);
                        order = SortOrder.DESCENDING;
                        break;
                    }
                    default:
                        jj_la1[10] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                ;
        }
        {
            if ("" != null) return new QuerySortColumn(column, order);
        }
        throw new Error("Missing return statement in function");
    }

    final public void GroupByAggregate() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        List<QueryDerivedColumn> aggregatedColumns;
        List<QueryColumn> groupByColumns;
        try {
            jj_consume_token(K_AGG_LIST);
            jjtn000.setType(OperatorType.AGGREGATE);
            jj_consume_token(O_LPAREN);
            jj_consume_token(O_LPAREN);
            aggregatedColumns = DerivedColumnList();
            jj_consume_token(O_RPAREN);
            jj_consume_token(O_COMMA);
            groupByColumns = GroupBy();
            jj_consume_token(O_RPAREN);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setArguments(aggregatedColumns, groupByColumns);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public List<QueryDerivedColumn> DerivedColumnList() throws ParseException {
        QueryDerivedColumn column;
        List<QueryDerivedColumn> columns = new ArrayList<QueryDerivedColumn>();
        column = DerivedColumn();
        columns.add(column);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case O_COMMA: {
                    ;
                    break;
                }
                default:
                    jj_la1[12] = jj_gen;
                    break label_3;
            }
            jj_consume_token(O_COMMA);
            column = DerivedColumn();
            columns.add(column);
        }
        {
            if ("" != null) return columns;
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryDerivedColumn DerivedColumn() throws ParseException {
        List<QueryColumn> inputs;
        String name;
        inputs = ColumnList();
        jj_consume_token(K_AS);
        jj_consume_token(S_IDENTIFIER);
        name = token.image;
        {
            if ("" != null) return new QueryDerivedColumn(name, inputs);
        }
        throw new Error("Missing return statement in function");
    }

    final public List<QueryColumn> GroupBy() throws ParseException {
        List<QueryColumn> columns;
        jj_consume_token(K_GROUP_BY);
        jj_consume_token(O_LPAREN);
        columns = ColumnList();
        jj_consume_token(O_RPAREN);
        {
            if ("" != null) return columns;
        }
        throw new Error("Missing return statement in function");
    }

    final public void Comparison() throws ParseException {/*@bgen(jjtree) Operator */
        QueryOperator jjtn000 = new QueryOperator(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jjtn000.setType(OperatorType.COMPARE);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case K_OP_AND: {
                    jj_consume_token(K_OP_AND);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.AND);
                    break;
                }
                case K_OP_OR: {
                    jj_consume_token(K_OP_OR);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.OR);
                    break;
                }
                case K_OP_NOT: {
                    jj_consume_token(K_OP_NOT);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.NOT);
                    break;
                }
                case K_OP_EQ: {
                    jj_consume_token(K_OP_EQ);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.EQ);
                    break;
                }
                case K_OP_LT: {
                    jj_consume_token(K_OP_LT);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.LT);
                    break;
                }
                case K_OP_LEQ: {
                    jj_consume_token(K_OP_LEQ);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.LEQ);
                    break;
                }
                case K_OP_GT: {
                    jj_consume_token(K_OP_GT);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.GT);
                    break;
                }
                case K_OP_GEQ: {
                    jj_consume_token(K_OP_GEQ);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.GEQ);
                    break;
                }
                case K_OP_NEQ: {
                    jj_consume_token(K_OP_NEQ);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.NEQ);
                    break;
                }
                case K_OP_LIKE: {
                    jj_consume_token(K_OP_LIKE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.LIKE);
                    break;
                }
                case K_OP_IN: {
                    jj_consume_token(K_OP_IN);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setArguments(ComparisonOperator.IN);
                    break;
                }
                default:
                    jj_la1[13] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public List<QueryColumn> ColumnList() throws ParseException {
        QueryColumn column;
        List<QueryColumn> columns = new ArrayList<QueryColumn>();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case O_DOT:
            case S_IDENTIFIER: {
                column = Column();
                columns.add(column);
                break;
            }
            case O_LT: {
                jj_consume_token(O_LT);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case O_DOT:
                    case S_IDENTIFIER: {
                        column = Column();
                        columns.add(column);
                        label_4:
                        while (true) {
                            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                case O_COMMA: {
                                    ;
                                    break;
                                }
                                default:
                                    jj_la1[14] = jj_gen;
                                    break label_4;
                            }
                            jj_consume_token(O_COMMA);
                            column = Column();
                            columns.add(column);
                        }
                        break;
                    }
                    default:
                        jj_la1[15] = jj_gen;
                        ;
                }
                jj_consume_token(O_GT);
                break;
            }
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) return columns;
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryColumn Column() throws ParseException {
        String scope = null;
        String name;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case S_IDENTIFIER: {
                jj_consume_token(S_IDENTIFIER);
                scope = token.image;
                break;
            }
            default:
                jj_la1[17] = jj_gen;
                ;
        }
        jj_consume_token(O_DOT);
        jj_consume_token(S_IDENTIFIER);
        name = token.image;
        {
            if ("" != null) return new QueryColumn(scope, name);
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * Generated Token Manager.
     */
    public QueryExpressionParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[18];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x3e000400, 0x1ffdbc0, 0x0, 0x3e000400, 0x0, 0x3c000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1ffc000, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x400, 0x100, 0x400, 0x0, 0x100, 0x400, 0x22000, 0x22040, 0x3, 0x3, 0x400, 0x0, 0x400, 0x22000, 0x22040, 0x20000,};
    }

    /**
     * Constructor with InputStream.
     */
    public QueryExpressionParser(InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public QueryExpressionParser(InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new QueryExpressionParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor.
     */
    public QueryExpressionParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new QueryExpressionParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new SimpleCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new QueryExpressionParserTokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor with generated Token Manager.
     */
    public QueryExpressionParser(QueryExpressionParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(QueryExpressionParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private List<int[]> jj_expentries = new ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[56];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 18; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 56; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}
